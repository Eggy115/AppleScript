property name_prefix : ""property name_suffix : ""property file_ext : "svg"property new_folder_name : "000-renamed"property find_and_replace : {to_find:{"line-"}, to_replace:{""}}-- global name_suffixon run	set source_folder to choose folder with prompt "Choose a folder of files to rename" as string	(*
	tell application "Finder"		set filecount to (count (get entire contents of source_folder))	end tell	return filecount
	*)	my do_main_script(source_folder)end runon do_main_script(source_folder)	tell application "Finder" to set source_folder to folder (source_folder)	tell application "Finder" to set target_folder to source_folder	--tell application "Finder" to set name_suffix to "-filetype-document-file"		if source_folder is not "" and target_folder is not "" then				tell application "Finder"			try				set svg_list to every file of source_folder whose name extension is file_ext				my create_new_folder(target_folder, new_folder_name)				set posix_target_folder to quoted form of POSIX path of ((target_folder as string) & new_folder_name as string)				log "posix_target_folder: " & posix_target_folder								repeat with svg_file in svg_list										set posix_src_file to quoted form of POSIX path of (svg_file as string)										set svg_name to (name of svg_file as string)										set new_name to my strip_prefix(svg_name)										repeat with n from 1 to count of (to_find of find_and_replace)						set new_name to my str_replace(item n of to_find of find_and_replace, item n of to_replace of find_and_replace, new_name)					end repeat										set new_name to name_prefix & my str_replace("." & file_ext as string, name_suffix, new_name) & "." & file_ext as string					set new_name to my change_case(new_name, 0)										set posix_new_file to quoted form of POSIX path of ((target_folder as string) & new_name as string)										set target_file_path to ((target_folder as string) & new_folder_name as string)										if not (exists target_file_path & ":" & svg_name) and not (exists target_file_path & ":" & new_name) then						set new_file to duplicate svg_file to target_file_path					else						set new_file to alias (target_file_path & ":" & svg_name)					end if					if not (exists target_file_path & ":" & new_name) then						try							set name of new_file to new_name						on error rename_err_str							log "Error renaming new file: " & rename_err_str						end try					end if									end repeat			on error errstr				log errstr			end try		end tell			end ifend do_main_scripton strip_prefix(the_string)	set prev_tids to text item delimiters of AppleScript	try		set text item delimiters of AppleScript to "_"		set text_items to text items of the_string		set new_string to text items 2 thru -1 of text_items		return new_string	on error errstr		set text item delimiters of AppleScript to prev_tids		log errstr	end try	set text item delimiters of AppleScript to prev_tids	return the_stringend strip_prefixon create_new_folder(target_folder, new_folder_name)	tell application "Finder"		try			set new_folder to make new folder at target_folder with properties {name:new_folder_name}			return new_folder		on error errstr			-- log errstr		end try	end tellend create_new_folderon str_replace(find, replace, subject)		try		set prevTIDs to text item delimiters of AppleScript		set returnList to true				-- This wouldn't make sense (you could have it raise an error instead)		if class of find is not list and class of replace is list then return subject				if class of find is not list then set find to {find}		if class of subject is not list then Â¬			set {subject, returnList} to {{subject}, false}				set findCount to count find		set usingReplaceList to class of replace is list				repeat with i from 1 to (count subject)			set thisSubject to item i of subject						repeat with n from 1 to findCount				set text item delimiters of AppleScript to item n of find				set thisSubject to text items of thisSubject								if usingReplaceList then					try						item n of replace					on error err_str						log err_str					end try				else					replace				end if								set text item delimiters of AppleScript to result				set thisSubject to "" & thisSubject			end repeat						set item i of subject to thisSubject		end repeat				set text item delimiters of AppleScript to prevTIDs		if not returnList then return beginning of subject		return subject			on error err_str		set text item delimiters of AppleScript to prevTIDs		log err_str	end try	end str_replaceon change_case(this_text, this_case)	if this_case is 0 then		set the comparison_string to "ABCDEFGHIJKLMNOPQRSTUVWXYZ"		set the source_string to "abcdefghijklmnopqrstuvwxyz"	else		set the comparison_string to "abcdefghijklmnopqrstuvwxyz"		set the source_string to "ABCDEFGHIJKLMNOPQRSTUVWXYZ"	end if	set the new_text to ""	repeat with this_char in this_text		set x to the offset of this_char in the comparison_string		if x is not 0 then			set the new_text to (the new_text & character x of the source_string) as string		else			set the new_text to (the new_text & this_char) as string		end if	end repeat	return the new_textend change_case